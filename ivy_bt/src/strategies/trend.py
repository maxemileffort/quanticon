"""
Trend Following Strategies
===========================

This module contains strategies that capitalize on sustained price movements
in a particular direction. These strategies typically use moving averages,
momentum indicators, and volatility filters to identify and trade trends.
"""

import pandas as pd
import numpy as np
import pandas_ta as ta

from .base import StrategyTemplate


class EMACross(StrategyTemplate):
    """
    Exponential Moving Average Crossover Strategy.
    
    Generates long signals when fast EMA crosses above slow EMA,
    and short signals when fast EMA crosses below slow EMA.
    """
    
    @classmethod
    def get_default_grid(cls):
        return {
            'fast': np.arange(5, 45, 1),
            'slow': np.arange(50, 200, 2)
        }

    def strat_apply(self, df):
        # Access parameters from the params dictionary
        fast = int(self.params.get('fast', 10))
        slow = int(self.params.get('slow', 50))

        df['ema_fast'] = ta.ema(df['close'], length=fast)
        df['ema_slow'] = ta.ema(df['close'], length=slow)
        
        # Drop NaN values generated by EMA warmup to avoid comparison errors
        df.dropna(subset=['ema_fast', 'ema_slow'], inplace=True)

        df['signal'] = np.nan
        long_condition = (
          df['ema_fast'] > df['ema_slow']
        )
        df.loc[long_condition, 'signal'] = 1
        short_condition = (
          df['ema_fast'] < df['ema_slow']
        )
        df.loc[short_condition, 'signal'] = -1
        df['signal'] = df['signal'].ffill().fillna(0)

        return df


class MACDTrend(StrategyTemplate):
    """
    MACD Trend Following Strategy.
    
    Trades in the direction of the MACD trend (above/below zero)
    when MACD line crosses the signal line.
    """
    
    @classmethod
    def get_default_grid(cls):
        return {
            'fast': np.arange(5, 30, 1),
            'slow': np.arange(30, 100, 2),
            'signal_period': np.arange(5, 20, 1)
        }

    def strat_apply(self, df):
        # 1. Parameter Extraction
        fast = self.params.get('fast', 12)
        slow = self.params.get('slow', 26)
        signal = self.params.get('signal_period', 9)

        # 2. Indicator Calculation
        # Using pandas_ta (ta) to calculate MACD components
        macd_df = ta.macd(df['close'], fast=fast, slow=slow, signal=signal)
        
        # Standardizing column names based on pandas_ta output format
        macd_col = f'MACD_{fast}_{slow}_{signal}'
        signal_col = f'MACDs_{fast}_{slow}_{signal}'
        
        df['macd_line'] = macd_df[macd_col]
        df['signal_line'] = macd_df[signal_col]

        # 3. Define Regimes and Crossovers
        bullish_regime = df['macd_line'] > 0
        bearish_regime = df['macd_line'] < 0
        
        macd_shifted = df['macd_line'].shift(1)
        sig_shifted = df['signal_line'].shift(1)

        # MACD line crossing above/below the Signal line
        bull_cross = (df['macd_line'] > df['signal_line']) & (macd_shifted <= sig_shifted)
        bear_cross = (df['macd_line'] < df['signal_line']) & (macd_shifted >= sig_shifted)

        # 4. Signal Logic
        df['signal'] = np.nan

        # Entry Conditions: Signals must align with the MACD regime (above/below zero)
        df.loc[bullish_regime & bull_cross, 'signal'] = 1   # Long
        df.loc[bearish_regime & bear_cross, 'signal'] = -1  # Short

        # Initial forward fill to hold position
        df['signal'] = df['signal'].ffill().fillna(0)

        # 5. Exit Logic: Regime Change
        # If the MACD line crosses the zero bound, the trend is considered broken
        regime_change = (df['macd_line'] * macd_shifted < 0)
        df['signal'] = df['signal'].mask(regime_change, 0)

        # 6. Final Persistence
        # Ensure the '0' (Cash) state is held until a new entry trigger occurs
        df['signal'] = df['signal'].ffill().fillna(0)

        return df


class Newsom10Strategy(StrategyTemplate):
    """
    Newsom10 Complex Trend Strategy.
    
    Combines ATR-based Chandelier Exits, EMA filters, Bollinger Band expansion,
    and volatility filters for high-confidence trend entries.
    """
    
    @classmethod
    def get_default_grid(cls):
        return {
            'atr_length': np.arange(5, 51, 2),
            'atr_mult': np.linspace(1.5, 5.0, 15),
            'bb_length': np.arange(5, 51, 2),
            'bb_mult': np.linspace(1.5, 5.0, 15),
            'ema_length': np.arange(5, 51, 2),
            'vol_ema_length': np.arange(5, 51, 2),
        }

    def strat_apply(self, df):
        # 1. Parameter Extraction
        atr_period = self.params.get('atr_period', 22)
        atr_mult = self.params.get('atr_mult', 3.0)
        bb_length = self.params.get('bb_length', 20)
        bb_mult = self.params.get('bb_mult', 2.0)
        ema_length = self.params.get('ema_length', 10)
        vol_ema_len = self.params.get('vol_ema_len', 20)

        # 2. Indicator Calculation
        df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=atr_period)
        df['ema_10'] = ta.ema(df['close'], length=ema_length)
        df['ohlc4'] = (df['open'] + df['high'] + df['low'] + df['close']) / 4

        # Volatility Filter
        df['atr_ratio'] = (df['atr'] / df['close']) * 100
        df['vol_filter_ema'] = ta.ema(df['atr_ratio'], length=vol_ema_len)
        df['vol_filter_active'] = df['atr_ratio'] > df['vol_filter_ema']

        # Bollinger Bands Expansion
        bbands = ta.bbands(df['close'], length=bb_length, std=bb_mult)
        df['bb_upper'] = bbands.iloc[:, 2]
        df['bb_lower'] = bbands.iloc[:, 0]
        df['band_dist'] = df['bb_upper'] - df['bb_lower']
        df['expansion'] = df['band_dist'] > df['band_dist'].shift(1)

        # 3. Chandelier Exit (Trailing Stop Logic)
        high_length = df['close'].rolling(window=atr_period).max()
        low_length = df['close'].rolling(window=atr_period).min()

        long_stop_raw = high_length - (df['atr'] * atr_mult)
        short_stop_raw = low_length + (df['atr'] * atr_mult)

        close_arr = df['close'].values
        ls_arr = long_stop_raw.fillna(0).values.copy()
        ss_arr = short_stop_raw.fillna(0).values.copy()
        directions = np.zeros(len(df))

        curr_dir = 1
        for i in range(1, len(df)):
            # Trailing Long Stop logic
            if close_arr[i-1] > ls_arr[i-1]:
                ls_arr[i] = max(ls_arr[i], ls_arr[i-1])

            # Trailing Short Stop logic
            if close_arr[i-1] < ss_arr[i-1]:
                ss_arr[i] = min(ss_arr[i], ss_arr[i-1])

            # Direction switch
            if close_arr[i] > ss_arr[i-1]:
                curr_dir = 1
            elif close_arr[i] < ls_arr[i-1]:
                curr_dir = -1
            directions[i] = curr_dir

        df['dir'] = directions

        # 4. Signal Logic
        df['signal'] = np.nan

        long_condition = (
            (df['close'] > df['ema_10']) &
            (df['close'].shift(1) < df['open'].shift(1)) &
            (df['ohlc4'] > df['ema_10']) &
            (df['dir'] == 1) &
            (df['expansion']) &
            (df['vol_filter_active'])
        )

        short_condition = (
            (df['close'] < df['ema_10']) &
            (df['close'].shift(1) > df['open'].shift(1)) &
            (df['ohlc4'] < df['ema_10']) &
            (df['dir'] == -1) &
            (df['expansion']) &
            (df['vol_filter_active'])
        )

        df.loc[long_condition, 'signal'] = 1
        df.loc[short_condition, 'signal'] = -1

        # 5. Persistence and Exit
        df['signal'] = df['signal'].ffill().fillna(0)

        # Flatten when Chandelier Direction changes
        flatten_condition = (
            (df['dir'] != df['dir'].shift(1)) &
            (df['signal'] != 0)
        )

        df['signal'] = df['signal'].mask(flatten_condition, 0)

        # Ensure position stays flat after mask until next entry signal
        df['signal'] = df['signal'].ffill().fillna(0)

        return df
    
class MarkovChainTrendProbability(StrategyTemplate):
    @classmethod
    def get_default_grid(cls):
        return {
            'lookback_period': np.arange(5, 30, 2),
            'atr_threshold': np.arange(0.1, 1.1, 0.1),
            'history_length': np.arange(10, 50, 5),
            'atr_length': np.arange(5, 30, 2)
        }

    def strat_apply(self, df):
        # 1. Parameter Extraction
        lookback_period = self.params.get('lookback_period', 14)
        atr_threshold = self.params.get('atr_threshold', 0.5)
        history_length = self.params.get('history_length', 33)
        atr_length = self.params.get('atr_length', 14)

        # 2. Indicator Calculation
        # Ensure column names are standardized to lowercase as per BacktestEngine requirements
        df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=atr_length)
        
        # Calculate ATR-normalized price change
        price_change = df['close'] - df['close'].shift(lookback_period)
        atr_normalized_change = price_change / df['atr']

        # 3. State Identification
        # Logic: if change > threshold -> Up (1), if < -threshold -> Down (-1), else NaN for ffill
        state_cond = np.where(
            atr_normalized_change > atr_threshold, 1, 
            np.where(atr_normalized_change < -atr_threshold, -1, np.nan)
        )
        
        # Vectorized forward fill to simulate 'keep previous state' behavior
        current_state = pd.Series(state_cond, index=df.index).ffill().fillna(1)

        # 4. Calculate State Probabilities (Vectorized Rolling Window)
        is_up = (current_state == 1).astype(int)
        is_down = (current_state == -1).astype(int)
        
        prob_uptrend = is_up.rolling(window=history_length).mean()
        prob_downtrend = is_down.rolling(window=history_length).mean()

        # 5. Signal Generation Logic
        df['signal'] = np.nan
        
        # Entry Conditions based on decision boundaries
        long_condition = (prob_uptrend > prob_downtrend) & (prob_uptrend > 0.5)
        short_condition = (prob_downtrend > prob_uptrend) & (prob_downtrend > 0.5)

        df.loc[long_condition, 'signal'] = 1
        df.loc[short_condition, 'signal'] = -1

        # 6. Persistence
        # Final forward fill ensures the strategy holds positions until a counter-signal occurs
        df['signal'] = df['signal'].ffill().fillna(0)

        return df

class TrendGridTrading(StrategyTemplate):
    @classmethod
    def get_default_grid(cls):
        return {
            'grid_count': np.arange(5, 51, 5),
            'upper_mult': np.arange(1.05, 1.30, 0.05),
            'lower_mult': np.arange(0.70, 0.95, 0.05)
        }

    def strat_apply(self, df):
        # 1. Parameter Extraction
        if df.empty:
            df['signal'] = 0
            return df

        # Use the first price as the anchor for the static grid
        first_price = df['close'].iloc[0]
        
        upper_mult = self.params.get('upper_mult', 1.10)
        lower_mult = self.params.get('lower_mult', 0.90)
        grid_count = self.params.get('grid_count', 10)
        
        upper_bound = first_price * upper_mult
        lower_bound = first_price * lower_mult

        # 2. Grid Level Generation
        grid_levels = np.linspace(lower_bound, upper_bound, int(grid_count))

        # 3. Standardize Columns
        close = df['close']
        prev_close = df['close'].shift(1)

        # 4. Vectorized Signal Logic (Trend Following)
        # Initialize signal as NaN to allow for effective forward filling
        df['signal'] = np.nan
        
        long_condition = pd.Series(False, index=df.index)
        short_condition = pd.Series(False, index=df.index)

        # Trend Following Logic: 
        # - Go Long when price breaks ABOVE a level (Strength)
        # - Go Short when price breaks BELOW a level (Weakness)
        for level in grid_levels:
            # Crossover level -> Buy/Long (Breakout)
            long_condition |= (prev_close < level) & (close >= level)
            # Crossunder level -> Sell/Short (Breakdown)
            short_condition |= (prev_close > level) & (close <= level)

        # Apply signals: Long is 1, Short is -1
        df.loc[long_condition, 'signal'] = 1
        df.loc[short_condition, 'signal'] = -1

        # 5. Final Persistence
        # Ensure the directional bias is held until the price hits another grid level
        # in the opposite direction.
        df['signal'] = df['signal'].ffill().fillna(0)

        return df